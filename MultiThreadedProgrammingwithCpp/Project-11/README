/*

Using Timed Locks
    Example demonstrates how to use a timed mutex. 
    Counter class uses a timed_mutex in combination with a unique_lock. 
    A relative time of 200 milliseconds is given to the unique_lock constructor, causing it to try to obtain a lock 
    for 200 milliseconds. 
    If the lock cannot be obtained within this timeout interval, the constructor returns.
    Afterward, you can check whether or not the lock has been acquired. 
    You can do this with an if statement on the lock variable, because unique_lock defines a bool conversion operator. 

    class Counter
    {
        public:
            Counter(int id, int numIterations) : mId(id), mNumIterations(numIterations)
            {
            }

            void operator()() const
            {
                for (int i = 0; i < mNumIterations; ++i) 
                {
                    unique_lock lock(sTimedMutex, 200ms);

                    if (lock) 
                    {
                        cout << "Counter " << mId << " has value " << i << endl;
                    } else 
                    {
                        // Lock not acquired in 200ms, skip output.
                    }
                }
            }

        private:
            int mId;
            int mNumIterations;
            static timed_mutex sTimedMutex;
                
    };

    timed_mutex Counter::sTimedMutex;
    

*/     