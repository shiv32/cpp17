/*

Iterators
    The Standard Library uses the iterator pattern to provide a generic abstraction for accessing the
    elements of a container.

    You can think of an iterator as a pointer to a specific element of the container. 
    Like pointers to elements in an array, iterators can move to the next element with operator++. 
    Similarly, you can usually use operator* and operator-> on the iterator to access the actual element 
    or field of the element. 
    Some iterators allow comparison with operator== and operator!=, and support operator-- for moving to 
    previous elements.

    All iterators must be copy constructible, copy assignable, and destructible. 
    Lvalues of iterators must be swappable. 
    Different containers provide iterators with slightly different additional capabilities.
    
    The standard defines five categories of iterators, as below.

            ITERATOR CATEGORY

            Input (also known as Read)
                operator++
                operator*
                operator->
                copy constructor
                operator=
                operator==
                operator!=

                Provides read-only access, forward only (no operator-- to move backward).
                Iterators can be assigned, copied, and compared for equality.

            Output (also known as Write)
                operator++
                operator*
                copy constructor
                operator=

                Provides write-only access, forward only.
                Iterators can be assigned, but cannot be compared for equality.
                Specific to output iterators is that you can do *iter = value.
                Note the absence of operator-> .
                Provides both prefix and postfix operator++ .

            Forward
                Capabilities of input iterators, plus default constructor.

                Provides read access, forward only.
                Iterators can be assigned, copied, and compared for equality.

            Bidirectional
                Capabilities of forward iterators, plus operator--

                Provides everything a forward iterator provides.
                Iterators can also move backward to a previous element.
                Provides both prefix and postfix operator--.

            Random Access
                Bidirectional capability,
                plus the following:
                operator+
                operator-
                operator+=
                operator-=
                operator<
                operator>
                operator<=
                operator>=
                operator[]

                Equivalent to raw pointers: support pointer arithmetic, array index syntax, and all forms of
                comparison.


    Iterators that satisfy the requirements for output iterators are called mutable iterators,
    otherwise they are called constant iterators.

    You can use std::distance() to compute the distance between two iterators of a container.

    Iterators are implemented similarly to smart pointer classes in that they overload the specific desired
    operators.

    The basic iterator operations are similar to those supported by raw pointers, so a raw pointer can be
    a legitimate iterator for certain containers. 
    In fact, the vector iterator could technically be implemented as a simple raw pointer.
    As a client of the containers, you need not worry about the implementation details; 
    you can simply use the iterator abstraction.

    NOTE:   Iterators might, or might not, be implemented internally as pointers, so this text uses the 
            term “refers to” instead of “points to” when discussing the elements accessible via an iterator.

    NOTE:   Only the sequential containers, ordered associative containers, and unordered associative containers 
            provide iterators. 
            The container adaptors and bitset class do not support iteration over their elements.

    Every container class in the Standard Library that supports iterators provides public type aliases
    for its iterator types, called iterator and const_iterator. 
    For example, a const iterator for a vector of ints has as type std::vector<int>::const_iterator. 
    Containers that allow you to iterate over their elements in reverse order also provide public type 
    aliases called reverse_iterator and const_reverse_iterator.

    NOTE: const_iterators and const_reverse_iterators provide read-only access to elements of the container.

    The containers also provide a method begin() that returns an iterator referring to the first element
    in the container. 
    The end() method returns an iterator to the “past-the-end” value of the sequence of elements. 
    That is, end() returns an iterator that is equal to the result of applying operator++ to an iterator 
    referring to the last element in the sequence. 
    Together, begin() and end() provide a half-open range that includes the first element but not the last. 
    The reason for this apparent complication is to support empty ranges (containers without any elements), 
    in which case begin() is equal to end(). 
    The half-open range bounded by iterators begin() and end() is often written mathematically like this: [begin, end).

    NOTE:   The half-open range concept also applies to iterator ranges that are passed to container methods such 
            as insert() and erase().

    Similarly, there are
        ➤➤ cbegin() and cend() methods that return const iterators.
        ➤➤ rbegin() and rend() methods that return reverse iterators.
        ➤➤ crbegin() and crend() methods that return const reverse iterators.

    NOTE:    The Standard Library also provides global non-member functions called std::begin(), end(), cbegin(),
             cend(), rbegin(), rend(), crbegin(), and crend(). 
             It’s recommended to use these non-member functions instead of the member versions.

*/