/*

CONTAINERS OVERVIEW
    Containers in the Standard Library are generic data structures that are useful for storing collections
    of data.
    You should rarely need to use a standard C-style array, write a linked list, or design a stack
    when you use the Standard Library.
    The containers are implemented as class templates, so you can instantiate them for any type that meets 
    certain basic conditions.
    Most of the Standard Library containers, except for array and bitset, are flexible in size and 
    automatically grow or shrink to accommodate more or fewer elements.
    Because of the fixed-size nature of standard C-style arrays, they are more vulnerable to overruns, 
    which in the simplest cases merely cause the program to crash because data has been corrupted, but in 
    the worst cases allow certain kinds of security attacks. 
    By using Standard Library containers, you ensure that your programs will be less vulnerable to these 
    kinds of problems.

    The Standard Library provides 16 containers, divided into four categories.

                Sequential containers
                    ➤ vector (dynamic array)
                    ➤ deque
                    ➤ list
                    ➤ forward_list
                    ➤ array

                Associative containers
                    ➤ map
                    ➤ multimap
                    ➤ set
                    ➤ multiset

                Unordered associative containers or hash tables
                    ➤ unordered_map
                    ➤ unordered_multimap
                    ➤ unordered_set
                    ➤ unordered_multiset

                Container adaptors
                    ➤ queue
                    ➤ priority_queue
                    ➤ stack

    C++ strings and streams can also be used as Standard Library containers to a certain degree, 
    and bitset can be used to store a fixed number of bits.

    Everything in the Standard Library is in the std namespace. 
    Use the blanket using namespace std; statement in source files (never use this in header files!).
    You can be more selective in your own programs about which symbols from std to use.

    Requirements on Elements
        Standard Library containers use value semantics on elements. 
        That is, they store a copy of elements that they are given, assign to elements with the 
        assignment operator, and destroy elements with the destructor. 

        Thus, when you write classes that you intend to use with the Standard Library, you need
        to make sure they are copyable. 
        When requesting an element from the container, a reference to the stored copy is returned.

        If you prefer reference semantics, you can store pointers to elements instead of the elements 
        themselves.
        When the containers copy a pointer, the result still refers to the same element. 

        An alternative is to store std::reference_wrappers in the container. 

        A reference_wrapper can be created using std::ref() or std::cref(), and basically exist to make 
        references copyable. 

        The reference_wrapper class template, and the ref() and cref() function templates are defined in 
        the <functional> header. 

        It is possible to store move-only types, that is non-copyable types, in a container, but when doing
        so, some operations on the container might not compile. 
        An example of a move-only type is std::unique_ptr.

        WARNING: If you want to store pointers in containers, use unique_ptr if the container becomes owner 
                 of the pointed-to object, or shared_ptr if the container shares ownership with other owners. 
                 Do not use the old, deprecated (removed in C++17) auto_ptr class in containers 
                 because it does not implement copying correctly (as far as the Standard Library is concerned).

        One of the template type parameters for Standard Library containers is a so-called allocator. 
        The container can use this allocator to allocate and deallocate memory for elements. 
        The allocator type parameter has a default value, so you can almost always just ignore it.

        Some containers, such as a map, also accept a comparator as one of the template type parameters. 
        This comparator is used to order elements. 
        It has a default value, so you don’t always have to specify it. 

        The specific requirements on elements in containers using the default allocator and comparator are
        below.

            METHOD
            
            Copy Constructor
                Creates a new element that is “equal” to the old one, but that can safely be destructed without 
                affecting  the old one.

                Used every time you insert an element, except when using an emplace method.

            Move Constructor
                Creates a new element by moving all content from a source element to the new element.

                Used when the source element is an rvalue, and will be destroyed after the construction of the 
                new element; 
                also used when a vector grows in size. 
                The move constructor should be noexcept, otherwise it won’t be used!

            Assignment Operator
                Replaces the contents of an element with a copy of the source element.

                Used every time you modify an element.

            Move Assignment Operator
                Replaces the contents of an element by moving all content from a source element.

                Used when the source element is an rvalue, and will be destroyed after the assignment operation. 
                The move assignment operator should be noexcept, otherwise it won’t be used!

            Destructor
                Cleans up an element.

                Used every time you remove an element, or when a vector grows in size and the elements are not 
                noexcept movable.

            Default Constructor
                Constructs an element without any arguments.

                Required only for certain operations, such as the vector::resize() method with one argument, and 
                the map::operator[] access.

            operator==
                Compares two elements for equality.

                Required for keys in unordered associative containers, and for certain operations, such as operator== 
                on two containers.

            operator<
                Determines if one element is less than another.

                Required for keys in ordered associative containers, and for certain operations, such as operator< 
                on two containers.


    For move semantics to work properly with Standard Library containers, the move constructor and the move 
    assignment operator must be marked as noexcept!

    WARNING: The Standard Library containers often call the copy constructor and copy assignment operator for 
             elements, so make those operations efficient.
             You can also increase performance by implementing move semantics for your elements.

Exceptions and Error Checking
    The Standard Library containers provide limited error checking.
    Consult a Standard Library Reference for a list of possible exceptions thrown from each method.

Iterators
    The Standard Library uses the iterator pattern to provide a generic abstraction for accessing the
    elements of a container.

    You can think of an iterator as a pointer to a specific element of the container. 
    Like pointers to elements in an array, iterators can move to the next element with operator++. 
    Similarly, you can usually use operator* and operator-> on the iterator to access the actual element 
    or field of the element. 
    Some iterators allow comparison with operator== and operator!=, and support operator-- for moving to 
    previous elements.

    All iterators must be copy constructible, copy assignable, and destructible. 
    Lvalues of iterators must be swappable. 
    Different containers provide iterators with slightly different additional capabilities.
    
    The standard defines five categories of iterators, as below.

            ITERATOR CATEGORY

            Input (also known as Read)
                operator++
                operator*
                operator->
                copy constructor
                operator=
                operator==
                operator!=

                Provides read-only access, forward only (no operator-- to move backward).
                Iterators can be assigned, copied, and compared for equality.

            Output (also known as Write)
                operator++
                operator*
                copy constructor
                operator=

                Provides write-only access, forward only.
                Iterators can be assigned, but cannot be compared for equality.
                Specific to output iterators is that you can do *iter = value.
                Note the absence of operator-> .
                Provides both prefix and postfix operator++ .

            Forward
                Capabilities of input iterators, plus default constructor.

                Provides read access, forward only.
                Iterators can be assigned, copied, and compared for equality.

            Bidirectional
                Capabilities of forward iterators, plus operator--

                Provides everything a forward iterator provides.
                Iterators can also move backward to a previous element.
                Provides both prefix and postfix operator--.

            Random Access
                Bidirectional capability,
                plus the following:
                operator+
                operator-
                operator+=
                operator-=
                operator<
                operator>
                operator<=
                operator>=
                operator[]

                Equivalent to raw pointers: support pointer arithmetic, array index syntax, and all forms of
                comparison.


    Iterators that satisfy the requirements for output iterators are called mutable iterators,
    otherwise they are called constant iterators.

    You can use std::distance() to compute the distance between two iterators of a container.

    Iterators are implemented similarly to smart pointer classes in that they overload the specific desired
    operators.

    The basic iterator operations are similar to those supported by raw pointers, so a raw pointer can be
    a legitimate iterator for certain containers. 
    In fact, the vector iterator could technically be implemented as a simple raw pointer.
    As a client of the containers, you need not worry about the implementation details; 
    you can simply use the iterator abstraction.

    NOTE:   Iterators might, or might not, be implemented internally as pointers, so this text uses the 
            term “refers to” instead of “points to” when discussing the elements accessible via an iterator.

    NOTE:   Only the sequential containers, ordered associative containers, and unordered associative containers 
            provide iterators. 
            The container adaptors and bitset class do not support iteration over their elements.

    Every container class in the Standard Library that supports iterators provides public type aliases
    for its iterator types, called iterator and const_iterator. 
    For example, a const iterator for a vector of ints has as type std::vector<int>::const_iterator. 
    Containers that allow you to iterate over their elements in reverse order also provide public type 
    aliases called reverse_iterator and const_reverse_iterator.

    NOTE: const_iterators and const_reverse_iterators provide read-only access to elements of the container.

    The containers also provide a method begin() that returns an iterator referring to the first element
    in the container. 
    The end() method returns an iterator to the “past-the-end” value of the sequence of elements. 
    That is, end() returns an iterator that is equal to the result of applying operator++ to an iterator 
    referring to the last element in the sequence. 
    Together, begin() and end() provide a half-open range that includes the first element but not the last. 
    The reason for this apparent complication is to support empty ranges (containers without any elements), 
    in which case begin() is equal to end(). 
    The half-open range bounded by iterators begin() and end() is often written mathematically like this: [begin, end).

    NOTE:   The half-open range concept also applies to iterator ranges that are passed to container methods such 
            as insert() and erase().

    Similarly, there are
        ➤➤ cbegin() and cend() methods that return const iterators.
        ➤➤ rbegin() and rend() methods that return reverse iterators.
        ➤➤ crbegin() and crend() methods that return const reverse iterators.

    NOTE:    The Standard Library also provides global non-member functions called std::begin(), end(), cbegin(),
             cend(), rbegin(), rend(), crbegin(), and crend(). 
             It’s recommended to use these non-member functions instead of the member versions.

*/  