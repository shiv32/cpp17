/*

The **most common architectural patterns** for a **C++ library** depend on its purpose, but here are the top **three** widely used ones:

### **1. Layered Architecture (Most Common & Versatile)**
âœ… **Best for:** Networking, database, game engines, and general-purpose libraries.  
âœ… **Why?** Provides a **modular, structured, and maintainable** design.  

#### **Example: A Database Library**

+-------------------------+
| Public API (User Layer) |  --> Exposes functions like `executeQuery()`
+-------------------------+
| Business Logic Layer    |  --> SQL parsing, caching, error handling
+-------------------------+
| Infrastructure Layer    |  --> Direct OS interactions (Sockets, File I/O)
+-------------------------+

##### **Implementation (C++)**

// Infrastructure Layer (Low-Level)
class Storage {
public:
    void readData() { std::cout << "Reading data from disk\n"; }
};

// Business Logic Layer
class QueryProcessor {
public:
    void processQuery() { std::cout << "Processing SQL query\n"; }
};

// Public API Layer
class Database {
    Storage storage;
    QueryProcessor processor;
public:
    void executeQuery() {
        processor.processQuery();
        storage.readData();
    }
};

âœ… **Advantages:**  
âœ” Easy to **maintain & test**  
âœ” Promotes **code separation & reusability**  
âœ” Scales well for large libraries  


### **2. Plugin Architecture (For Extensible Libraries)**
âœ… **Best for:** Graphics, compression, and simulation libraries.  
âœ… **Why?** Allows **dynamic module loading and easy extensibility**.  

#### **Example: A Rendering Library**
+----------------------+
| Rendering API        |  --> User calls `render()`
+----------------------+
| Renderer Plugins     |  --> OpenGL, Vulkan, DirectX implementations
+----------------------+
| Core Engine         |  --> Handles plugin loading
+----------------------+
```

##### **Implementation (C++)**

// Abstract Renderer Interface
class Renderer {
public:
    virtual void render() = 0;
};

// OpenGL Renderer Plugin
class OpenGLRenderer : public Renderer {
public:
    void render() override { std::cout << "Rendering with OpenGL\n"; }
};

// Plugin Loader
class RendererFactory {
public:
    static std::unique_ptr<Renderer> createRenderer(const std::string& type) {
        if (type == "OpenGL") return std::make_unique<OpenGLRenderer>();
        return nullptr;
    }
};

âœ… **Advantages:**  
âœ” Supports **multiple backends**  
âœ” Allows **runtime loading/unloading of components**  

### **3. Event-Driven Architecture (For Asynchronous Processing)**
âœ… **Best for:** GUI frameworks, game engines, message queues.  
âœ… **Why?** Decouples components and improves responsiveness.  

#### **Example: A GUI Button System**

+----------------------+
| UI Components       |  --> Buttons, Labels, Windows
+----------------------+
| Event System        |  --> Dispatches events to listeners
+----------------------+

##### **Implementation (C++)**

class Listener {
public:
    virtual void onEvent(const std::string& event) = 0;
};

// Button triggering events
class Button {
    std::vector<Listener*> listeners;
public:
    void addListener(Listener* listener) { listeners.push_back(listener); }
    void click() {
        for (auto* listener : listeners) listener->onEvent("Button Clicked");
    }
};

âœ… **Advantages:**  
âœ” Reduces **tight coupling** between components  
âœ” Improves **asynchronous handling**  

Which One Should You Use?

        Pattern     :   Layered Architecture	
        Best For    :   General-purpose C++ libraries (networking, databases)	
        Why Use It? :   Most common, modular, and maintainable

        Pattern     :   Plugin Architecture	
        Best For    :   Extensible systems (graphics, simulations, IDEs)	
        Why Use It? :   Supports multiple backends and dynamic modules

        Pattern     :   Event-Driven Architecture	
        Best For    :   Asynchronous/event-based systems (GUIs, game engines)	
        Why Use It? :   Decouples components and improves scalability

### **Final Thoughts**  
ðŸ”¹ If your library is **general-purpose**, use Layered Architecture.  
ðŸ”¹ If your library **needs dynamic extensions**, use Plugin Architecture.  
ðŸ”¹ If your library **relies on events or async communication**, use Event-Driven Architecture.  

*/