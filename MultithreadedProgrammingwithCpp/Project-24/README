/*

THREADING DESIGN AND BEST PRACTICES
    This section briefly lists a few best practices related to multithreaded programming.

    Use parallel Standard Library algorithms: 
        The Standard Library contains a large collection of algorithms. 
        Since C++17, more than 60 of them support parallel execution! 
        Whenever possible, use such parallel algorithms instead of writing your own multithreaded code. 

    Before closing the application, make sure all thread objects are unjoinable: 
        Make sure that either join() or detach() has been called on all thread objects. 
        Destructors of threads that are still joinable will call std::terminate() which abruptly terminates 
        all threads and the application.

    The best synchronization is no synchronization: 
        Multithreaded programming becomes much easier if you manage to design your different threads in such a way 
        that all threads working on shared data read only from that shared data and never write to it, or only write 
        to parts never read by other threads. 
        In that case, there is no need for any synchronization, and you cannot have problems like data races or 
        deadlocks.

    Try to use the single-thread ownership pattern: 
        This means that a block of data is owned by no more than one thread at a time. 
        Owning the data means that no other thread is allowed to read from or write to the data. 
        When the thread is finished with the data, the data can be passed off to another thread, which now has 
        sole and complete responsibility/ownership of the data. 
        No synchronization is necessary in this case.

    Use atomic types and operations when possible: 
        Atomic types and atomic operations make it easier to write data-race and deadlock-free code, because they 
        handle synchronization automatically. 
        If atomic types and operations are not possible in your multithreaded design, and you need shared data, 
        you have to use some synchronization mechanism, such as mutual exclusion, to ensure proper synchronization.

    Use locks to protect mutable shared data: 
        If you need mutable shared data to which multiple threads can write, and you cannot use atomic types and 
        operations, you have to use a locking mechanism to make sure that reads and writes between different 
        threads are synchronized.

    Release locks as soon as possible: 
        When you need to protect your shared data with a lock, make sure that you release the lock as soon as possible. 
        While a thread is holding a lock, it is blocking other threads waiting for the same lock, possibly hurting performance.

    Do not manually acquire multiple locks, instead use std::lock() or std::try_lock():
        If multiple threads need to acquire multiple locks, they must be acquired in the same order in all threads 
        to prevent deadlocks. 
        You should use the generic std::lock() or std::try_lock() functions to acquire multiple locks.

    Use RAII lock objects: 
        Use the lock_guard, unique_lock, shared_lock, or scoped_lock RAII classes to automatically release locks at the right time.

    Use a multithreading-aware profiler: 
        This helps to find performance bottlenecks in your multithreaded applications, and to find out if your multiple threads are indeed utilizing all available processing power in your system. 
        An example of a multithreading-aware profiler is the profiler in certain editions of Microsoft Visual Studio.

    Understand the multithreading support features of your debugger: 
        Most debuggers have at least basic support for debugging multithreaded applications. 
        You should be able to get a list of all running threads in your application, and you should be able to switch to any one of those threads to inspect their call stack. 
        You can use this, for example, to inspect deadlocks because you can see exactly what each thread is doing.

    Use thread pools instead of creating and destroying a lot of threads dynamically: 
        Your performance decreases if you dynamically create and destroy a lot of threads. 
        In that case, itâ€™s better to use a thread pool to reuse existing threads.

    Use higher-level multithreading libraries: 
        The C++ standard, at this moment, only provides basic building blocks for writing multithreaded code. 
        Using those correctly is not trivial.
        Where possible, use higher-level multithreading libraries such as Intel Threading Building Blocks (TBB), Microsoft Parallel Patterns Library (PPL), and so on, rather than reinventing the wheel. 
        Multithreaded programming is hard to get right, and is error prone. 
        More often than not, your wheel may not be as round as you think.

*/