/*

Run-Time Type Facilities
        One of the primary values of the typeid operator is for logging and debugging purposes.

            eg.
                class Loggable
                {
                    public:
                    virtual ~Loggable() = default;
                    virtual std::string getLogMessage() const = 0;
                };

                class Foo : public Loggable
                {
                    public:
                    std::string getLogMessage() const override;
                };

                std::string Foo::getLogMessage() const
                {
                    return "Hello logger.";
                }

                void logObject(const Loggable& loggableObject)
                {
                    cout << typeid(loggableObject).name() << ": ";
                    cout << loggableObject.getLogMessage() << endl;
                }

        The logObject() function takes a “loggable” object as a parameter. 
        The design is such that any object that can be logged inherits from the Loggable class and supports 
        a method called getLogMessage().

        Here is the output generated by Microsoft Visual C++ 2017 when the logObject() function is called with
        an instance of Foo:

            class Foo: Hello logger.

        The name returned by the typeid operator is “class Foo”. 
        This name depends on your compiler. 
        For example, if you compile the same code with GCC, the output is as follows:

            3Foo: Hello logger.


    NOTE:   If you are using typeid for purposes other than logging and debugging,
            consider reimplementing it using virtual methods.

*/  