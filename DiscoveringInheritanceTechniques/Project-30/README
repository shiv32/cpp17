/*

Run-Time Type Facilities
    Relative to other object-oriented languages, C++ is very compile-time oriented.
    Overriding methods works because of a level of indirection between a method and
    its implementation, not because the object has built-in knowledge of its own class. 

    There are features in C++ that provide a run-time view of an object.
    These features are commonly grouped together under a feature set called run-time type information, or RTTI.

    RTTI provides a number of useful features for working with information about an object’s class membership.

        One such feature is dynamic_cast(), which allows you to safely convert between types within
        an object-oriented hierarchy.
        Using dynamic_cast() on a class without a vtable, that is, without any virtual methods, causes a compilation
        error.

        A second RTTI feature is the typeid operator, which lets you query an object at run time to find
        out its type. 
        For the most part, you shouldn’t ever need to use typeid because any code that is conditionally run 
        based on the type of the object would be better handled with virtual methods.

        The following code uses typeid to print a message based on the type of the object:

                #include <typeinfo>

                class Animal { public: virtual ~Animal() = default; };
                class Dog : public Animal {};
                class Bird : public Animal {};

                void speak(const Animal& animal)
                {
                
                    if (typeid(animal) == typeid(Dog)) {

                        cout << "Woof!" << endl;

                    } else if (typeid(animal) == typeid(Bird)) {

                        cout << "Chirp!" << endl;

                    }

                }

        Whenever you see code like this, you should immediately consider reimplementing the functionality
        as a virtual method. 
        In this case, a better implementation would be to declare a virtual method called speak() in the Animal
        class. 
        Dog would override the method to print "Woof!" and 
        Bird would override the method to print "Chirp!". 
        This approach better fits object-oriented programming, where functionality related to objects is 
        given to those objects.

        WARNING:    The typeid operator only works correctly if the class has at least
                    one virtual method, that is, when the class has a vtable. 
                    The typeid operator also strips reference and const qualifiers from its argument.

        One of the primary values of the typeid operator is for logging and debugging purposes.

            eg.
                class Loggable
                {
                    public:
                    virtual ~Loggable() = default;
                    virtual std::string getLogMessage() const = 0;
                };

                class Foo : public Loggable
                {
                    public:
                    std::string getLogMessage() const override;
                };

                std::string Foo::getLogMessage() const
                {
                    return "Hello logger.";
                }

                void logObject(const Loggable& loggableObject)
                {
                    cout << typeid(loggableObject).name() << ": ";
                    cout << loggableObject.getLogMessage() << endl;
                }

        The logObject() function takes a “loggable” object as a parameter. 
        The design is such that any object that can be logged inherits from the Loggable class and supports 
        a method called getLogMessage().

        Here is the output generated by Microsoft Visual C++ 2017 when the logObject() function is called with
        an instance of Foo:

            class Foo: Hello logger.

        The name returned by the typeid operator is “class Foo”. 
        This name depends on your compiler. 
        For example, if you compile the same code with GCC, the output is as follows:

            3Foo: Hello logger.


    NOTE:   If you are using typeid for purposes other than logging and debugging,
            consider reimplementing it using virtual methods.

*/  